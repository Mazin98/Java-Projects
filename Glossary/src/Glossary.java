import java.util.Arrays;
import java.util.Comparator;

import components.map.Map;
import components.map.Map.Pair;
import components.map.Map1L;
import components.set.Set;
import components.set.Set1L;
import components.simplereader.SimpleReader;
import components.simplereader.SimpleReader1L;
import components.simplewriter.SimpleWriter;
import components.simplewriter.SimpleWriter1L;

/**
 * This program generates a glossary of words that are presented in an unordered
 * list, and each word in the list is hyperlinked t o its definition. In the
 * event that a word appears in a definition, a hyperlink is created to allow
 * the user to easily navigate back to that word's definition.f that word.
 *
 * @author Mazin Tagelsir
 *
 */
public final class Glossary {

    /**
     * Private constructor so this utility class cannot be instantiated.
     */
    private Glossary() {
    }

    /**
     *
     * Gets a map of words and definition from the text file given in the data
     * by the user.
     *
     * @param input
     *            a text file from the data folder
     * @param wordsDef
     *            the words -> it's definition
     * @updates wordsDef
     * @requires <pre> for the last set of words and definitions in the text
     *           file, there should be an empty line proceeding the last line
     *           </pre>
     * @ensures <pre> wordsDef = a set of words(k) and definitions(v) with all
     *          of the sets within the text file </pre>
     */
    public static void getWordsAndDefinitions(SimpleReader input,
            Map<String, String> wordsDef) {

        //declaring strings empty
        String def, nextLine, word, empty = "";

        boolean end = false;

        //while there is still input
        while (!input.atEOS()) {
            word = input.nextLine();
            nextLine = input.nextLine();
            def = "";
            while (!nextLine.equals(empty) && !end) {

                def = def + nextLine; //def is after the word
                if (!input.atEOS()) {
                    nextLine = input.nextLine(); //then input the next Line
                } else {
                    end = true; //will end the loop
                }

            }
            wordsDef.add(word, def); //adds word & def to the map
        }
    }

    /**
     * Outputs the "opening" tags in the generated HTML file. These are the
     * expected elements generated by this method:
     *
     * <html> <head> <title>Glossary
     * <h2>Glossary</h2>
     * <hr>
     * <h3>Index</h3>
     *
     *
     * @param out
     *            the output stream
     * @updates out.content
     * @ensures out.content = #out.content * [the HTML "opening" tags]
     */
    private static void startingIndexHTML(SimpleWriter out) {

        //html stuff below
        out.println("<!DOCTYPE html>");
        out.println("<html lang=\'en\'>");
        out.println("<title>Glossary</title>");
        out.println("</head>");
        out.println("<body>");
        out.println("<h2>Glossary</h2>");
        out.println("<hr>");
        out.println("<h3>Index</h3>");
        out.println("<ul>");
    }

    /**
     * Outputs a list of all the keywords in the {@code Map} and prints them out
     * in an unordered list in html in alphabetical order with hyperlinks to its
     * definition. example of an iteration:
     *
     * @param map
     *            words -> definitions
     * @param out
     *            the output stream
     * @updates out.content
     * @ensures out.content = #out.content * [the HTML "body" tags and the
     *          unordered list with hyperlinks to those definitions]
     */
    private static void endingIndexHTML(Map<String, String> map,
            SimpleWriter out) {

        String[] strArray = new String[map.size()]; //array thats map size
        int i = 0;

        //runs through map
        for (Map.Pair<String, String> tempPair : map) {
            String str = tempPair.key(); //str  = word
            strArray[i++] = str; //iterates
        }
        //sorts the array after
        Arrays.sort(strArray, new Comparator<String>() {

            @Override
            public int compare(String o1, String o2) {
                return o1.compareTo(o2);
            }
        });

        //iterates over tempArray
        //outputs the HTML with hyperlink to
        for (String tempStr : strArray) {
            out.print("<li><a href='");
            out.print(tempStr + ".html"); //goes to different html file
            out.print("'>");
            out.print(tempStr); //print the str in the array
            out.print("</a></li>");
            out.println();
        }

        out.println("</ul>");
        out.println("</body>");
        out.println("</html>");
    }

    /**
     * Returns a string of the definition with hyperlinks to each word if there
     * are any in the definition.
     *
     * @param map
     *            words and definitions
     * @param separatorSet
     *            A set of separator characters
     * @param currentDef
     *            the current definition being printed out to its word on the
     *            html file
     * @return a string of {@code String}
     * @ensures <pre> result = currentDef ||
     * currentDef * [hyperlink to keys in map] </pre>
     */
    private static String replaceKeywordWithLink(Map<String, String> map,
            Set<Character> separatorSet, String currentDef) {

        StringBuffer result = new StringBuffer();

        int position = 0;

        //if the position is less than the length of definition
        while (position < currentDef.length()) {
            String token = nextWordOrSeparator(currentDef, position,
                    separatorSet);

            //if the word has "token"
            if (map.hasKey(token)) {
                result.append("<a href='" + token + ".html'>" + token + "</a>");
            } else {
                result.append(token); //add
            }
            position += token.length(); //add the length to the position
        }
        return result.toString(); //StringBuffer to string and return

    }

    /**
     * Prints out a page with the word highlighted in red in the top right
     * corner and the definition, with keywords having hyperlinks linked back to
     * it's definition.
     *
     * @param map
     *            words to definitions
     * @param pair
     *            the current pair of word and definition that are being printed
     *            to the file
     * @param set
     *            a set of separator characters
     * @param out
     *            the output stream
     *
     * @updates tempDef
     * @ensures <pre> result = currentDef ||
     * currentDef * [hyperlink to keys in map] </pre>
     */
    private static void defHTML(Map<String, String> map,
            Pair<String, String> pair, Set<Character> set, SimpleWriter out) {

        String word = pair.key();
        String definition = pair.value();
        out.println("<!DOCTYPE html>");
        out.println("<html lang=\'en\'>");
        out.println("<head>");
        out.println("<title>" + word + "</title>");
        out.println("<body>");
        out.println("<h2><b><i><font color='red'>");
        out.print(word + "</font></i></b></h2>");

        //send to the method to change keyword
        definition = replaceKeywordWithLink(map, set, definition);

        out.println("<blockquote>" + definition + "</blockquote>");

        out.println("<hr/>");
        out.println("<p>Return to <a href=\"index.html\">index</a>.</p>");
        out.println("</body>");
        out.println("</html>");

    }

    /**
     * Generates the set of characters in the given {@code String} into the
     * given {@code Set}.
     *
     * @param str
     *            the given {@code String}
     * @param set
     *            the {@code Set} to be replaced
     * @replaces charSet
     * @ensures charSet = entries(str)
     */
    public static void generateElements(String str, Set<Character> set) {
        assert str != null : "Violation of: str is not null";
        assert set != null : "Violation of: charSet is not null";

        int size = str.length();

        //loop through map
        for (int i = 0; i < size; i++) {
            char tempStr = str.charAt(i);
            if (!set.contains(tempStr)) { //if it doesn't have
                set.add(tempStr); //add it
            }

        }
    }

    /**
     * Returns the first "word" (maximal length string of characters not in
     * {@code separators}) or "separator string" (maximal length string of
     * characters in {@code separators}) in the given {@code text} starting at
     * the given {@code position}.
     *
     * @param text
     *            the {@code String} from which to get the word or separator
     *            string
     * @param position
     *            the starting index
     * @param set
     *            the {@code Set} of separator characters
     * @return the first word or separator string found in {@code text} starting
     *         at index {@code position}
     * @requires 0 <= position < |text|
     * @ensures <pre>
     * nextWordOrSeparator =
     *   text[position, position + |nextWordOrSeparator|)  and
     * if entries(text[position, position + 1)) intersection separators = {}
     * then
     *   entries(nextWordOrSeparator) intersection separators = {}  and
     *   (position + |nextWordOrSeparator| = |text|  or
     *    entries(text[position, position + |nextWordOrSeparator| + 1))
     *      intersection separators /= {})
     * else
     *   entries(nextWordOrSeparator) is subset of separators  and
     *   (position + |nextWordOrSeparator| = |text|  or
     *    entries(text[position, position + |nextWordOrSeparator| + 1))
     *      is not subset of separators)
     * </pre>
     */
    public static String nextWordOrSeparator(String text, int position,
            Set<Character> set) {
        assert text != null : "Violation of: text is not null";
        assert set != null : "Violation of: separators is not null";
        assert 0 <= position : "Violation of: 0 <= position";
        assert position < text.length() : "Violation of: position < |text|";

        StringBuilder result = new StringBuilder();
        boolean sep = true;

        //gets the character at the position
        char startChar = text.charAt(position);

        //if set has char
        if (set.contains(startChar)) {

            //loop through string ------- if sep is true
            for (int i = position; i < text.length() && sep; i++) {

                //if set has same string
                if (set.contains(text.charAt(i))) {
                    char temp = text.charAt(i); //new char = string at position i
                    result.append(temp); //add char to the return string
                } else {
                    sep = false;
                }
            }
        } else {
            sep = false;

            for (int i = position; i < text.length() && !sep; i++) {

                /*
                 * if the set doesnt have the character then declare temp to
                 * that character and add it to the final result. if not then
                 * declare sep to true. Once this is all finished we change the
                 * whole result to a string to return it.
                 */
                if (!set.contains(text.charAt(i))) {
                    char temp = text.charAt(i);
                    result.append(temp);
                } else {
                    sep = true;
                }
            }

        }
        return result.toString();
    }

    /**
     * Main method.
     *
     * @param args
     *            the command line arguments
     */
    public static void main(String[] args) {

        SimpleWriter out = new SimpleWriter1L();
        SimpleReader in = new SimpleReader1L();
        out.println("Enter a valid link for the dictionary: ");
        String fileInLocation = in.nextLine();
        out.println(
                "Enter a valid folder for where you would like the output to be:");
        String fileOutLocation = in.nextLine();
        final String separatorStr = " \t,?;:!/.";
        Set<Character> separatorSet = new Set1L<>();

        //moves them to generate elements method
        generateElements(separatorStr, separatorSet);

        String index = "index.html"; //main index

        SimpleReader textInput = new SimpleReader1L(fileInLocation);
        SimpleWriter textOutput = new SimpleWriter1L(
                fileOutLocation + "/" + index);

        Map<String, String> wordsDef = new Map1L<String, String>();
        getWordsAndDefinitions(textInput, wordsDef);

        startingIndexHTML(textOutput);
        endingIndexHTML(wordsDef, textOutput);

        for (Pair<String, String> pair : wordsDef) {
            String tempWord = pair.key();
            SimpleWriter tempFileOut = new SimpleWriter1L(
                    fileOutLocation + "/" + tempWord + ".html");
            defHTML(wordsDef, pair, separatorSet, tempFileOut);
        }

        in.close();
        out.close();
    }
}
